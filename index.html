<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>TrankiMama</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 0; padding: 16px; }
    #map { height: 420px; border-radius: 12px; background:#eef1f4; }
    .controls { margin: 12px 0; display: flex; gap: 8px; flex-wrap: wrap; }
    button { padding: 8px 12px; border: 0; border-radius: 8px; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    hr { margin: 16px 0; }
    li { margin: 6px 0; }
    .meta { color:#555; font-size: 0.9em; margin-left: 4px; }
  </style>
</head>
<body>
  <h1>TrankiMama</h1>
  <div id="map"></div>

  <div class="controls">
    <button id="btnStart"  onclick="startTracking()">Comenzar</button>
    <button id="btnStop"   onclick="pauseTracking()" disabled>Detener</button>
    <button id="btnResume" onclick="resumeTracking()" disabled>Retomar</button>
    <button id="btnSave"   onclick="saveRoute()" disabled>Guardar</button>
    <button id="btnClear"  onclick="clearCurrent()" disabled>Limpiar actual</button>
    <button id="btnSOS"    onclick="sendSOS()" disabled>üî¥ SOS</button>
    <button id="btnShare"  onclick="copyShareLink()" disabled>Compartir enlace</button>
  </div>

  <hr />
  <h2>Mis rutas</h2>
  <ul id="routes"></ul>

  <p id="statusOffline" style="color:red; display:none;">Sin conexi√≥n: se guardar√° la ruta y se enviar√° cuando haya se√±al‚Ä¶</p>
  <p id="lastCoord">√öltima posici√≥n: N/A</p>
  <p id="shareLink">Enlace de seguimiento: N/A</p>

  <script>
    // ===== Config de filtrado =====
    const MAX_ACC  = 40; // metros: ignora posiciones con peor precisi√≥n
    const MIN_DIST = 5;  // metros: ignora movimientos menores a este umbral

    // ===== Estado =====
    let map;
    let watchId = null;            // null => sin seguimiento activo
    let currentPath = [];          // [{lat, lng, t, acc}]
    let currentPolyline = null;
    let currentMarker = null;
    let drawnPolyline = null;      // para visualizar rutas guardadas
    let routes = [];               // [{id, name, createdAt, distanceMeters, path:[...]}]

    // ===== Nuevos estados para compartir y SOS =====
    let shareToken = null;      // token √∫nico de seguimiento
    let shareURL = null;        // URL de seguimiento construida a partir del token
    let unsentPositions = [];   // posiciones acumuladas cuando no hay conexi√≥n

    // ===== Inicio =====
    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 40.4168, lng: -3.7038 }, // Madrid por defecto
        zoom: 14,
        mapTypeControl: false
      });
      routes = loadFromLocalStorage();
      renderRouteList();
      updateButtons();

      // Actualiza el estado offline inicial y escucha cambios de conexi√≥n
      updateOfflineStatus();
      window.addEventListener('online', updateOfflineStatus);
      window.addEventListener('offline', updateOfflineStatus);
    }

    // ===== Helpers =====
    const isTracking = () => watchId !== null;
    const hasCurrent = () => currentPath.length > 0;

    function ensurePolylineAndMarker() {
      if (!currentPolyline) {
        currentPolyline = new google.maps.Polyline({
          path: [],
          geodesic: true,
          strokeColor: '#FF0000',
          strokeOpacity: 1.0,
          strokeWeight: 3,
          map
        });
      }
      if (!currentMarker) {
        currentMarker = new google.maps.Marker({ map, title: 'Mi posici√≥n' });
      }
    }

    // ===== Comenzar (nueva ruta) =====
    function startTracking() {
      if (isTracking()) return;

      // Si hay trazado actual sin guardar, confirmamos borrar
      if (hasCurrent()) {
        const ok = confirm('Ya tienes un trazado en curso. ¬øDeseas descartarlo y comenzar una ruta nueva?');
        if (!ok) return;
        clearCurrent(); // limpia sin preguntar de nuevo
      }

      currentPath = [];
      ensurePolylineAndMarker();

      // Genera un nuevo token de seguimiento y actualiza el enlace
      shareToken = generateShareToken();
      updateShareLink();
      // Limpia posiciones pendientes por si quedaban de una ruta anterior
      unsentPositions = [];

      watchId = navigator.geolocation.watchPosition(onPosition, onGeoError, {
        enableHighAccuracy: true,
        maximumAge: 10000,
        timeout: 20000
      });

      updateButtons();
    }

    // ===== Detener (pausa) =====
    function pauseTracking() {
      if (isTracking()) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      updateButtons();
    }

    // ===== Retomar (contin√∫a la misma ruta) =====
    function resumeTracking() {
      if (isTracking() || !hasCurrent()) return; // ya activo o no hay nada que retomar
      ensurePolylineAndMarker();
      watchId = navigator.geolocation.watchPosition(onPosition, onGeoError, {
        enableHighAccuracy: true,
        maximumAge: 10000,
        timeout: 20000
      });
      updateButtons();
    }

    // ===== Limpia trazado actual =====
    function clearCurrent() {
      if (isTracking()) pauseTracking();
      currentPath = [];
      if (currentPolyline) { currentPolyline.setMap(null); currentPolyline = null; }
      if (currentMarker)   { currentMarker.setMap(null); currentMarker = null; }

      // Resetea token y enlace al limpiar una ruta sin guardar
      shareToken = null;
      updateShareLink();

      // Restablece la √∫ltima posici√≥n mostrada
      document.getElementById('lastCoord').textContent = '√öltima posici√≥n: N/A';
      updateButtons();
    }

    // ===== Posici√≥n entrante =====
    function onPosition(pos) {
      const { latitude, longitude, accuracy } = pos.coords;
      if (accuracy > MAX_ACC) return; // filtra mala precisi√≥n

      const p = { lat: latitude, lng: longitude, t: Date.now(), acc: accuracy };

      // evita puntos casi iguales (ahorra bater√≠a/almacenamiento)
      if (currentPath.length > 0) {
        const last = currentPath[currentPath.length - 1];
        const d = google.maps.geometry.spherical.computeDistanceBetween(
          new google.maps.LatLng(last.lat, last.lng),
          new google.maps.LatLng(p.lat, p.lng)
        );
        if (d < MIN_DIST) { 
          // actualiza la posici√≥n del marcador aunque no a√±adamos punto
          if (currentMarker) currentMarker.setPosition({ lat: p.lat, lng: p.lng });
          return;
        }
      } else {
        map.setCenter({ lat: p.lat, lng: p.lng });
      }

      currentPath.push(p);
      ensurePolylineAndMarker();
      currentPolyline.getPath().push(new google.maps.LatLng(p.lat, p.lng));
      currentMarker.setPosition({ lat: p.lat, lng: p.lng });

      // Actualiza la √∫ltima coordenada mostrada al usuario
      const lastText = `√öltima posici√≥n: ${p.lat.toFixed(5)}, ${p.lng.toFixed(5)} - ${new Date(p.t).toLocaleTimeString()}`;
      document.getElementById('lastCoord').textContent = lastText;

      // Si estamos offline, guarda la posici√≥n para enviarla m√°s tarde
      if (!navigator.onLine) {
        unsentPositions.push(p);
      }

      updateButtons();
    }

    function onGeoError(err) {
      console.error('Geolocation error:', err);
      alert('No se pudo obtener la posici√≥n (' + err.message + '). Revisa permisos/GPS.');
    }

    // ===== Guardar ruta =====
    function saveRoute() {
      if (currentPath.length < 2) {
        alert('Necesitas al menos dos puntos para guardar una ruta.');
        return;
      }
      const llArray = currentPath.map(p => new google.maps.LatLng(p.lat, p.lng));
      const distanceMeters = google.maps.geometry.spherical.computeLength(llArray);

      const route = {
        id: Date.now(),
        name: `Ruta ${routes.length + 1}`,
        createdAt: new Date().toISOString(),
        distanceMeters,
        path: currentPath
      };

      routes.push(route);
      saveToLocalStorage(routes);
      renderRouteList();

      alert('Ruta guardada.');
      clearCurrent();
    }

    // ===== Lista de rutas =====
    function renderRouteList() {
      const list = document.getElementById('routes');
      list.innerHTML = '';

      if (!routes.length) {
        const li = document.createElement('li');
        li.textContent = 'No tienes rutas guardadas a√∫n.';
        list.appendChild(li);
        return;
      }

      routes.forEach((r) => {
        const li = document.createElement('li');

        const a = document.createElement('a');
        a.href = '#';
        a.textContent = r.name;
        a.onclick = () => { showRoute(r.id); };

        const km = (r.distanceMeters / 1000).toFixed(2);
        const when = new Date(r.createdAt).toLocaleString();

        const meta = document.createElement('span');
        meta.className = 'meta';
        meta.textContent = ` ¬∑ ${km} km ¬∑ ${when}`;

        // Exportaciones
        const sep1 = document.createTextNode(' ¬∑ ');
        const aGJ = document.createElement('a');
        aGJ.href = '#';
        aGJ.textContent = 'GeoJSON';
        aGJ.onclick = () => exportRoute(r.id, 'geojson');

        const sep2 = document.createTextNode(' / ');
        const aGPX = document.createElement('a');
        aGPX.href = '#';
        aGPX.textContent = 'GPX';
        aGPX.onclick = () => exportRoute(r.id, 'gpx');

        li.appendChild(a);
        li.appendChild(meta);
        li.appendChild(sep1);
        li.appendChild(aGJ);
        li.appendChild(sep2);
        li.appendChild(aGPX);
        list.appendChild(li);
      });
    }

    function showRoute(id) {
      const r = routes.find(x => x.id === id);
      if (!r || !r.path?.length) return;

      if (drawnPolyline) drawnPolyline.setMap(null);

      drawnPolyline = new google.maps.Polyline({
        path: r.path.map(p => ({ lat: p.lat, lng: p.lng })),
        geodesic: true,
        strokeColor: '#0371B3',
        strokeOpacity: 1.0,
        strokeWeight: 3,
        map
      });

      const bounds = new google.maps.LatLngBounds();
      r.path.forEach(p => bounds.extend(new google.maps.LatLng(p.lat, p.lng)));
      if (!bounds.isEmpty()) map.fitBounds(bounds);
    }

    // ===== Exportaci√≥n =====
    function download(name, content, mime) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([content], { type: mime }));
      a.download = name;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function routeToGeoJSON(r) {
      return JSON.stringify({
        type: "Feature",
        properties: {
          id: r.id,
          name: r.name,
          createdAt: r.createdAt,
          distance_m: Math.round(r.distanceMeters)
        },
        geometry: {
          type: "LineString",
          coordinates: r.path.map(p => [p.lng, p.lat]) // [lng, lat]
        }
      }, null, 2);
    }

    function routeToGPX(r) {
      const trkpts = r.path.map(p =>
        `<trkpt lat="${p.lat}" lon="${p.lng}"><time>${new Date(p.t).toISOString()}</time></trkpt>`
      ).join('');
      return `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="TrankiMama" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata><time>${new Date(r.createdAt).toISOString()}</time><name>${r.name}</name></metadata>
  <trk><name>${r.name}</name><trkseg>${trkpts}</trkseg></trk>
</gpx>`;
    }

    function exportRoute(id, fmt) {
      const r = routes.find(x => x.id === id);
      if (!r) return;
      if (fmt === 'geojson') {
        download(`ruta-${r.id}.geojson`, routeToGeoJSON(r), 'application/geo+json');
      } else if (fmt === 'gpx') {
        download(`ruta-${r.id}.gpx`, routeToGPX(r), 'application/gpx+xml');
      }
    }

    // ===== Storage =====
    function saveToLocalStorage(data) {
      localStorage.setItem('routes', JSON.stringify(data));
    }
    function loadFromLocalStorage() {
      try {
        const raw = localStorage.getItem('routes');
        return raw ? JSON.parse(raw) : [];
      } catch (e) {
        console.error('Error leyendo localStorage:', e);
        return [];
      }
    }

    // ===== UI =====
    function updateButtons() {
      const tracking = isTracking();
      const points = currentPath.length;

      document.getElementById('btnStart').disabled  = tracking;
      document.getElementById('btnStop').disabled   = !tracking;
      document.getElementById('btnResume').disabled = tracking || points === 0;
      document.getElementById('btnSave').disabled   = points < 2;
      document.getElementById('btnClear').disabled  = points === 0;

      // SOS solo disponible si hay al menos una posici√≥n en la ruta
      document.getElementById('btnSOS').disabled    = points === 0;
      // Compartir enlace solo disponible si hay token generado
      document.getElementById('btnShare').disabled  = !shareToken;
    }

    // ===== Funciones de generaci√≥n y copia de enlace =====
    // Genera un token aleatorio para el seguimiento
    function generateShareToken() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let token = '';
      for (let i = 0; i < 16; i++) {
        token += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return token;
    }

    // Actualiza el texto del enlace de seguimiento en la interfaz
    function updateShareLink() {
      const linkElem = document.getElementById('shareLink');
      if (shareToken) {
        // Construye una URL sencilla con el token. En una app real, esto apuntar√≠a a un visor web que consume el token
        shareURL = `${location.origin}${location.pathname}?id=${shareToken}`;
        linkElem.textContent = 'Enlace de seguimiento: ' + shareURL;
        document.getElementById('btnShare').disabled = false;
      } else {
        shareURL = null;
        linkElem.textContent = 'Enlace de seguimiento: N/A';
        document.getElementById('btnShare').disabled = true;
      }
    }

    // Copia el enlace de seguimiento al portapapeles para compartir con familiares
    function copyShareLink() {
      if (!shareURL) return;
      navigator.clipboard.writeText(shareURL).then(() => {
        alert('Enlace copiado al portapapeles. ¬°Comp√°rtelo con tu familiar!');
      }).catch((err) => {
        alert('No se pudo copiar el enlace: ' + err);
      });
    }

    // ===== Funci√≥n SOS =====
    // Crea un mensaje con la √∫ltima posici√≥n y copia al portapapeles para facilitar el aviso a emergencias
    function sendSOS() {
      if (currentPath.length === 0) {
        alert('No hay una ruta activa ni posici√≥n reciente para enviar.');
        return;
      }
      const last = currentPath[currentPath.length - 1];
      const lat = last.lat.toFixed(5);
      const lng = last.lng.toFixed(5);
      const message = `Necesito ayuda. Mi √∫ltima ubicaci√≥n conocida es: ${lat}, ${lng}.`;
      navigator.clipboard.writeText(message).catch(() => {});
      alert('SOS\n' + message + '\nEl mensaje se ha copiado al portapapeles. Llama a emergencias (p. ej., 112) y pega este texto.');
    }

    // ===== Manejo de conexi√≥n y env√≠o diferido =====
    // Muestra/oculta el estado offline y procesa posiciones acumuladas al volver a estar en l√≠nea
    function updateOfflineStatus() {
      const offline = !navigator.onLine;
      const statusElem = document.getElementById('statusOffline');
      if (offline) {
        statusElem.style.display = 'block';
      } else {
        statusElem.style.display = 'none';
        // Aqu√≠ se podr√≠an enviar las posiciones acumuladas a un servidor
        if (unsentPositions.length > 0) {
          console.log('Enviando posiciones almacenadas:', unsentPositions);
          // Reinicia el buffer
          unsentPositions = [];
        }
      }
    }

    // Mensaje √∫til si la key/referrer falla
    window.gm_authFailure = function() {
      alert('Fallo de autenticaci√≥n de Google Maps JS API: revisa la API key y las restricciones de referrer.');
    };
  </script>

  <!-- IMPORTANTE: libraries=geometry para distancias -->
  <script src="https://maps.googleapis.com/maps/api/js?AIzaSyBq30NO3Wr-2MySK26-3Sh8WQdjbFUjX34&libraries=geometry&callback=initMap" async defer></script>
</body>
</html>
